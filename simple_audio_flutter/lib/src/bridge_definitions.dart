// AUTO GENERATED FILE, DO NOT EDIT.
// Generated by `flutter_rust_bridge`@ 1.82.1.
// ignore_for_file: non_constant_identifier_names, unused_element, duplicate_ignore, directives_ordering, curly_braces_in_flow_control_structures, unnecessary_lambdas, slash_for_doc_comments, prefer_const_literals_to_create_immutables, implicit_dynamic_list_literal, duplicate_import, unused_import, unnecessary_import, prefer_single_quotes, prefer_const_constructors, use_super_parameters, always_use_package_imports, annotate_overrides, invalid_use_of_protected_member, constant_identifier_names, invalid_use_of_internal_member, prefer_is_empty, unnecessary_const

import 'dart:convert';
import 'dart:async';
import 'package:meta/meta.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge.dart';
import 'package:uuid/uuid.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;

part 'bridge_definitions.freezed.dart';

abstract class SimpleAudioFlutter {
  Future<PlayerWrapper> newStaticMethodPlayerWrapper({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kNewStaticMethodPlayerWrapperConstMeta;

  Future<void> disposeStaticMethodPlayerWrapper({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kDisposeStaticMethodPlayerWrapperConstMeta;

  Stream<Duration> playbackStartedStreamStaticMethodPlayerWrapper(
      {dynamic hint});

  FlutterRustBridgeTaskConstMeta
      get kPlaybackStartedStreamStaticMethodPlayerWrapperConstMeta;

  Stream<PlaybackState> playbackStateStreamStaticMethodPlayerWrapper(
      {dynamic hint});

  FlutterRustBridgeTaskConstMeta
      get kPlaybackStateStreamStaticMethodPlayerWrapperConstMeta;

  Stream<ProgressState> progressStateStreamStaticMethodPlayerWrapper(
      {dynamic hint});

  FlutterRustBridgeTaskConstMeta
      get kProgressStateStreamStaticMethodPlayerWrapperConstMeta;

  Stream<Error> errorStreamStaticMethodPlayerWrapper({dynamic hint});

  FlutterRustBridgeTaskConstMeta
      get kErrorStreamStaticMethodPlayerWrapperConstMeta;

  Future<PlaybackState> playbackStateMethodPlayerWrapper(
      {required PlayerWrapper that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kPlaybackStateMethodPlayerWrapperConstMeta;

  Future<ProgressState> progressMethodPlayerWrapper(
      {required PlayerWrapper that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kProgressMethodPlayerWrapperConstMeta;

  /// Returns `true` if there is a file preloaded for playback.
  Future<bool> isPreloadedMethodPlayerWrapper(
      {required PlayerWrapper that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kIsPreloadedMethodPlayerWrapperConstMeta;

  Future<bool> isLoopingMethodPlayerWrapper(
      {required PlayerWrapper that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kIsLoopingMethodPlayerWrapperConstMeta;

  Future<bool> isNormalizingMethodPlayerWrapper(
      {required PlayerWrapper that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kIsNormalizingMethodPlayerWrapperConstMeta;

  Future<double> volumeMethodPlayerWrapper(
      {required PlayerWrapper that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kVolumeMethodPlayerWrapperConstMeta;

  Future<void> openMethodPlayerWrapper(
      {required PlayerWrapper that,
      required String path,
      required bool autoplay,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kOpenMethodPlayerWrapperConstMeta;

  Future<void> preloadMethodPlayerWrapper(
      {required PlayerWrapper that, required String path, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kPreloadMethodPlayerWrapperConstMeta;

  Future<void> playPreloadMethodPlayerWrapper(
      {required PlayerWrapper that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kPlayPreloadMethodPlayerWrapperConstMeta;

  Future<void> clearPreloadMethodPlayerWrapper(
      {required PlayerWrapper that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kClearPreloadMethodPlayerWrapperConstMeta;

  Future<void> playMethodPlayerWrapper(
      {required PlayerWrapper that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kPlayMethodPlayerWrapperConstMeta;

  Future<void> pauseMethodPlayerWrapper(
      {required PlayerWrapper that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kPauseMethodPlayerWrapperConstMeta;

  Future<void> stopMethodPlayerWrapper(
      {required PlayerWrapper that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kStopMethodPlayerWrapperConstMeta;

  Future<void> loopPlaybackMethodPlayerWrapper(
      {required PlayerWrapper that, required bool shouldLoop, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kLoopPlaybackMethodPlayerWrapperConstMeta;

  Future<void> setVolumeMethodPlayerWrapper(
      {required PlayerWrapper that, required double volume, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSetVolumeMethodPlayerWrapperConstMeta;

  Future<void> seekMethodPlayerWrapper(
      {required PlayerWrapper that, required Duration position, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSeekMethodPlayerWrapperConstMeta;

  Future<void> normalizeVolumeMethodPlayerWrapper(
      {required PlayerWrapper that,
      required bool shouldNormalize,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta
      get kNormalizeVolumeMethodPlayerWrapperConstMeta;

  DropFnType get dropOpaquePlayer;
  ShareFnType get shareOpaquePlayer;
  OpaqueTypeFinalizer get PlayerFinalizer;
}

@sealed
class Player extends FrbOpaque {
  final SimpleAudioFlutter bridge;
  Player.fromRaw(int ptr, int size, this.bridge) : super.unsafe(ptr, size);
  @override
  DropFnType get dropFn => bridge.dropOpaquePlayer;

  @override
  ShareFnType get shareFn => bridge.shareOpaquePlayer;

  @override
  OpaqueTypeFinalizer get staticFinalizer => bridge.PlayerFinalizer;
}

@freezed
sealed class Error with _$Error {
  /// An error occurred when trying to fetch more bytes for
  /// a network stream.
  const factory Error.networkStream(
    String field0,
  ) = Error_NetworkStream;

  /// An error occurred when decoding the file.
  const factory Error.decode(
    String field0,
  ) = Error_Decode;

  /// An error occurred when trying to open a file.
  const factory Error.open(
    String field0,
  ) = Error_Open;

  /// An error occurred when trying to preload a file.
  const factory Error.preload(
    String field0,
  ) = Error_Preload;
}

enum PlaybackState {
  /// The player is currently playing the file.
  play,

  /// The player is currently paused and there is no output.
  pause,

  /// The player has finished playing the file.
  done,

  /// The player was stopped
  stop,

  /// The player has automatically started playing the preloaded file.
  preloadPlayed,
}

class PlayerWrapper {
  final SimpleAudioFlutter bridge;
  final Player internal;

  const PlayerWrapper({
    required this.bridge,
    required this.internal,
  });

  static Future<PlayerWrapper> newPlayerWrapper(
          {required SimpleAudioFlutter bridge, dynamic hint}) =>
      bridge.newStaticMethodPlayerWrapper(hint: hint);

  static Future<void> dispose(
          {required SimpleAudioFlutter bridge, dynamic hint}) =>
      bridge.disposeStaticMethodPlayerWrapper(hint: hint);

  static Stream<Duration> playbackStartedStream(
          {required SimpleAudioFlutter bridge, dynamic hint}) =>
      bridge.playbackStartedStreamStaticMethodPlayerWrapper(hint: hint);

  static Stream<PlaybackState> playbackStateStream(
          {required SimpleAudioFlutter bridge, dynamic hint}) =>
      bridge.playbackStateStreamStaticMethodPlayerWrapper(hint: hint);

  static Stream<ProgressState> progressStateStream(
          {required SimpleAudioFlutter bridge, dynamic hint}) =>
      bridge.progressStateStreamStaticMethodPlayerWrapper(hint: hint);

  static Stream<Error> errorStream(
          {required SimpleAudioFlutter bridge, dynamic hint}) =>
      bridge.errorStreamStaticMethodPlayerWrapper(hint: hint);

  Future<PlaybackState> playbackState({dynamic hint}) =>
      bridge.playbackStateMethodPlayerWrapper(
        that: this,
      );

  Future<ProgressState> progress({dynamic hint}) =>
      bridge.progressMethodPlayerWrapper(
        that: this,
      );

  /// Returns `true` if there is a file preloaded for playback.
  Future<bool> isPreloaded({dynamic hint}) =>
      bridge.isPreloadedMethodPlayerWrapper(
        that: this,
      );

  Future<bool> isLooping({dynamic hint}) => bridge.isLoopingMethodPlayerWrapper(
        that: this,
      );

  Future<bool> isNormalizing({dynamic hint}) =>
      bridge.isNormalizingMethodPlayerWrapper(
        that: this,
      );

  Future<double> volume({dynamic hint}) => bridge.volumeMethodPlayerWrapper(
        that: this,
      );

  Future<void> open(
          {required String path, required bool autoplay, dynamic hint}) =>
      bridge.openMethodPlayerWrapper(
        that: this,
        path: path,
        autoplay: autoplay,
      );

  Future<void> preload({required String path, dynamic hint}) =>
      bridge.preloadMethodPlayerWrapper(
        that: this,
        path: path,
      );

  Future<void> playPreload({dynamic hint}) =>
      bridge.playPreloadMethodPlayerWrapper(
        that: this,
      );

  Future<void> clearPreload({dynamic hint}) =>
      bridge.clearPreloadMethodPlayerWrapper(
        that: this,
      );

  Future<void> play({dynamic hint}) => bridge.playMethodPlayerWrapper(
        that: this,
      );

  Future<void> pause({dynamic hint}) => bridge.pauseMethodPlayerWrapper(
        that: this,
      );

  Future<void> stop({dynamic hint}) => bridge.stopMethodPlayerWrapper(
        that: this,
      );

  Future<void> loopPlayback({required bool shouldLoop, dynamic hint}) =>
      bridge.loopPlaybackMethodPlayerWrapper(
        that: this,
        shouldLoop: shouldLoop,
      );

  Future<void> setVolume({required double volume, dynamic hint}) =>
      bridge.setVolumeMethodPlayerWrapper(
        that: this,
        volume: volume,
      );

  Future<void> seek({required Duration position, dynamic hint}) =>
      bridge.seekMethodPlayerWrapper(
        that: this,
        position: position,
      );

  Future<void> normalizeVolume({required bool shouldNormalize, dynamic hint}) =>
      bridge.normalizeVolumeMethodPlayerWrapper(
        that: this,
        shouldNormalize: shouldNormalize,
      );
}

class ProgressState {
  /// The position of the player.
  final Duration position;

  /// The duration of the file that is being played.
  final Duration duration;

  const ProgressState({
    required this.position,
    required this.duration,
  });
}
